---
layout: default
title:  "컴퓨터 그래픽스 정리"
date:   2021-05-21 09:00:00 +0200
published: 2021-06-09 09:00:00 +0200
comments: true
categories: graphics
tags: [graphics, animation, opengl]
github: "https://github.com/OYSSanghyuk"
---



<p>Topic : 2차원, 3차원 그래픽스, 컴퓨터 그래픽스의 활용, 컴퓨터 그래픽스의 표준, opengl


<h2>2차원 그래픽스</h2>

<h4>벡터 그래픽스</h4>
<p>그래픽 객체들을 수학적함수로 표현하여 그래픽 명령어의 형태로 컴퓨터의 기억 공간에 저장하여
	기하학적 객체를 수식의 형태로 표현하므로 화면을 확대해도 화질의 변화가 없는 것이 특징인 방식
</p>

<h4>레스터 그래픽스</h4>
<p>그래픽 객체들을 구성하고 있는 픽셀들의 값들이 메모리에 그대로 저장되는 방식</p>

<h2>3차원 그래픽스</h2>

<h4>모델링</h4>
<p>3차원 좌표계에서 가상의 물체의 모양을 표현하는 과정
와이어프레임모델에서는 물체의 형태를 와이어프레임이라 불리는 선분을 이용하여 표현
다각형 표면모델은 삼각형이나 사각형같은 면을 기본단위로하여 물체의 외형을 표현</p>


<h4>투영</h4>
<p>모델링과정으로 형태가 구성이 되면 투영과정을 거친다. 투영과정이란 3차원 객체를 2차원화면에
	보여지게 처리하는 과정으로 이는 우리가 실제로 보여지는 디스플레이가 2차원 출력장치이기 때문에 필요한 과정이다.</p>


<h4>색상과 명암부여(랜더링)</h4>
<p>렌더링과정은 색상, 명암, 재질 및 그림자 같은 3차원적인 요소를 더하여 현실감을 추구하는 과정이다.
	렌더링 과정은 보는 사람이 객체를 볼 때 가려져서 안 보이는 은면을 제거하고
	, 색상과 명암을 나타내는 셰이딩과정, 그림이나 이미지로 기하모델의 표현을 덮어씌우는 텍스처매핑과정이 있다.</p>


<h4>이미지처리(Image Processing)</h4>
<p>이미지를 디지털화 한 후 입력된 그림을 이미지처리 소프트웨어로 편집한다.
	편집과정에서 사진의 품질을 향상시키거나 특별한 효과를 추가한다.</p>


<h4>애니메이션(Animation)</h4>
<p>애니메이션은 정지된 그림이나 이미지를 연속적으로 초당 15프레임이상 디스플레이하여 사람이 연속된 동작으로 느끼게 하는 기술이다.</p>


<h4>가상현실(VR : virtual reality)</h4>
<p>컴퓨터 그래픽스 기술을 이용하여 가상공간이나 가상의 물체를 구축하여 관찰자가 가상공간을 돌아다니며 체험하게 한다.
	- 3차원 공간, 물체를 초당 15프레임이상 디스플레이해야한다.
</p>


<h4>증강현실(AR : Augmented reality)</h4>
<p>컴퓨터 그래픽스 기술을 이요하여 실제현실에 가상의 사물이나 정보를 합성한다.</p>


<h2>컴퓨터 그래픽스의 활용</h2>

<h4>CAD(Computer Aided Design)</h4>
<p>CAD는 그래픽스 기술로 컴퓨터를 이용한 설계 분야이다. CAD 소프트웨어를 이용하여
	건축설계, 자동차, 비행기등 매우 광범위한 분야의 설계 및 도면작성을 할 수 있다,</p>

<h4>컴퓨터 애니메이션과 시뮬레이션(Simulation)</h4>
<p>애니메이션은 그래픽 프레임들을 연속적인 디스플레이를 통해 자연스럽게 보여주는 기법이다.
시뮬레이션은 교육, 훈련분야에서 많이 쓰고 모의실험으로 사용자의 입력 데이터에 따라 디스플레이 되는 결과가 변한다.</p>

<h4>컴퓨터 디자인 및 아트</h4>
<p>그래픽스 소프트웨어를 이용해 광고나 홍보물을 제작하여 활용하고 있고, 이처럼 상업디자인에 많이 활용되고 있지만 창작미술에도 활용되고 있다, </p>

<h4>게임 및 엔터테인먼트</h4>
<p>영화, 뮤직비디오, 게임등 엔터테인먼트를 제작할 때 자주 사용되고 있다. </p>

<h4>프리젠테이션 및 데이터 시각화(Data Visualization)</h4>
<p>컴퓨터가 생성한 각종 데이터를 그래픽을 통하여 제시해주는 분야를 프리젠테이션 그래픽스라고한다. 데이터를 차트나 그래프를 이용하여 표현한다.
	그리고 이를 바탕으로 컴퓨터 생성모델을 통하여 시각함으로써 자연형상이나 물리적 현상을 이해, 예측하는데 큰 도움을 줄 수 있다.</p>

<h4>멀티미디어</h4>
<p>이미지, 그래픽, 사운드, 애니메이션, 비디오 등과 같은 매체에서 그래픽스는 자주 이용된다. </p>

<h4>GUI(Graphical User Interface)</h4>
<p>GUI는 윈도우, 아이콘, 메뉴와 같은 그래픽 인터페이스를 통해 시각적으로 원하는 작업을 편리하게 용이하게 수행할 수 있게 해준다. </p>


<h4>전자출판</h4>
<p>잡지나 서적과 같은 출판물을 제작하는데도 이용되는데 이를 전자출판, 탁상출판(DTP : Desk-Top Publishing)이라고 한다.
	이를 이용하여 출판물의 레이아웃을 설계하고 그림이나 사진을 쉽게 편집하여 삽입하는 등의 일을 효과적으로 처리할 수 있다.</p>


<h4>공간정보의 표현</h4>
<p>교통, 환경, 지리, 토지 등의 공간정보를 2차원 또는 3차원 그래픽스로 표현함으로써 최적해를 찾아 합리적 의사결정을 내릴 수 있다.
	이러한 분야를 지리정보시스템(GIS: Geographic Information System)이라고 한다.</p>

<h4>이미지처리</h4>
<p>이미지처리는 외부에서 입력된 이미지의 질을 향상시키거나 입력된 이미지의 정보를 컴퓨터가 분석하고 이해하기 위해 사용한다. 예를 들면 MRI나 CT가 있다.</p>

<h2>그래픽스 시스템의 구성</h2>
<p>그래픽스 시스템의 구성

     그래픽스 프로그램(ex)포토샵), 그래픽 DB
	    ↓
입력장치 -> 프로세서 -> 프레임버퍼 -> 출력
	    ↓
            메모리
 </p>

<p>프레임버퍼 : 시스템 메모리와 그래픽 출력결과를 일시 저장해주는 메모리
그래픽스 프로그램 : 일반적으로 그래픽스 라이브러리가 제공하는 API(Application Program Interface)를 이용하여 개발한다. </P>

<h2>컴퓨터 그래픽스의 표준</h2>

<p>API - 고급 프로그래밍언어에서 그래픽스라이브러리를 호출</p>
<p>장치 인터페이스 – 입출력 장치와 표준적 방식으로 상호소통</p>
<p>그래픽 데이터 교환 – 그래픽스 응용프로그램간에 그래픽 데이터의 교환 및 저장</p>

<hr>


<h2>OpenGL</h2>

<h4>OpenGL의 특징</h4>
<p>1. opengl은 그래픽스 하드웨어에 대한 소프트웨어 인터페이스이다. 하드웨어에 독립적이고, 상위 수준의 그래픽스API다.
2. OpenGL은 플랫폼에 독립적이다. PC나 워크스테이션 모두에서 가능하고 다양한 운영체제 및 호스트 언어를 지원한다.
3. 다양한 그래픽스 기능의 지원으로 응용 소프트웨어 개발이 용이하다. 기본적인 2D 및 3D 그래픽스 함수에서부터 고급 기능까지 지원하고 그래픽스 가속기를 통해 많은 양의 데이터 처리가능</p>

<h4>OpenGL의 장점</h4>
<p>1. 안정성 – 다양한 플랫폼에서 지원되어 그 사양이 충분히 검증되면서 발전
2. 신뢰성 및 이식성 – OpenGL응용프로그램은 운영체제나 윈도우 시스템에 상관없이 동일한 출력결과를 생성
3. 확장성 – 다양한 종류의 시스템에서 동일하게 작동
4. 편리성 – 직관적인 인터페이스와 논리적인 명령어들로 구성
5. 문서화 – 문서화 작업이 잘 이루어져 있어 많은 책들이 출판</p>

<h4>OpenGL 라이브러리의 구성</h4>
<p>GL Library
OpenGL의 메인 라이브러리 기본적인 함수들이 모여있다.
GLU Library
OpenGL의 고급 기능의 유틸리티 함수들이 모여있다.
GLUT Library
인터페이스 툴킷 라이브러리, 현재 다양한 플랫폼 지원</p>

<h4>예시 코드 : OpenGL로 사각형 그리기</h4>
<code>
#include <iostream>
#include <gl/glut.h>

void drawScene();
int main()
{
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowPostion(100, 100);
	glutInitWindowSize();
	glutCreateWindow(“Draw_Rect”);
	glutDisplayFunc(drawScene);

	glutMainLoop();
	return 0;
}

void drawScene()
{
	glClearColor()
	glClear(GL_COLOR_BUFFER_BIT);
	glColor4f()
	glBegin(GL_POLYGON);
		glVertex2i();
		glVertex2i();
		glVertex2i();	
		glVertex2i();
	glEnd();
	glFlush();
}
	</code>



<p>
To have a better understanding, we need to have the following concepts in mind.
Each broker can have :
</p>
<ul>
 	<li>1 or many transport connector to accept client connections (consumers or producers) and network connections from other brokers (receiving messages from other brokers). In our sample here we only have 1 transport connector per broker instance</li>
 	<li>1 or many network connectors to allow messages to be forwarded to other brokers</li>
</ul>
<p>In this article we will take the example of an IoT use case where the main focus is on : </p>
<ul>
 	<li>handing a large number of connected sensors</li>
 	<li>securing a central system that collects and processes messages</li>
</ul>
<p> In such scenario, we would like to set up a concentrator topology as shown below. </p>

<a href="/assets/images/{{page.id}}/brokernetworkconcentrator.png">
<img class="center-block img-responsive" src="/assets/images/{{page.id}}/brokernetworkconcentrator.png" alt="network of brokers concentrator topology"/></a>
<p>
This topology allows us to setup stable and controlled connections between the brokers of layer 1 towards layer 2. The central brokers do not have to deal with sensors connecting and disconnecting.

The green arrows define a network connector. Note that these have a direction. It means that brokers from layer 1 can forward messages to all brokers from layer 2.

We also allow messages to travel between brokers of layer 2. We will see later that this allows the network to better balance the workload and to facilitates scale ups/scale downs.
</p>
<h2>How to scale up ?</h2>
Scaling up is pretty straight in this setup :
<ul>
 	<li>To handle more connections, brokers can be added in layer 1</li>
 	<li>If the overall volume grows, extend the number of brokers in layer 2 to absorb the workload</li>
</ul>
<p>
Usually when scaling up, we want the clients already connected to be redistributed among the newly available brokers. This is especially important for the clients connected to the layer 2 as we might not want to statically bind them to one broker.

To achieve this we can set the following options within the transport connectors of the central brokers.
</p>
<ul>
 	<li>rebalanceClusterClients : allows the broker to disconnect clients and force them to reconnect to a less busy broker</li>
 	<li>updateClusterClients : updates client connections when a broker joins the network. In that way the clients do not need to be aware of all the brokers available when connecting for the first time. The clients only need to be able to connect to at least one.</li>
 	<li>updateClusterClientsOnRemove : updates client connections when a broker leaves the network.</li>
 	<li>updateClusterFilter : a regular expression that allows to trigger client updates only on certain brokers that join the network. In our case for example we only want brokers from layer 2 to trigger reconnects.</li>
</ul>

{% highlight xml %}
<transportConnectors>
	<transportConnector
		name="clients"
		rebalanceClusterClients="true"
		updateClusterClients="true"
		updateClusterClientsOnRemove="true"
		updateClusterFilter="amq-c.*"
		uri="tcp://localhost:61620" />
</transportConnectors>
{% endhighlight %}

 <p>
Further options on the transport connector can be found here :

<a href="https://access.redhat.com/documentation/en/red-hat-jboss-a-mq/6.3/paged/connection-reference/appendix-c-server-options">https://access.redhat.com/documentation/en/red-hat-jboss-a-mq/6.3/paged/connection-reference/appendix-c-server-options</a>
</p>
<h2>How to scale down?</h2>

<p>Scaling down is a bit more challenging. This is because when shutting down an instance, there might be still messages remaining in the broker.

The strategy we can apply to shut down a broker (named c01 in this example) properly in a network is the following :
</p>
<ul>
 	<li>Stop the transport connector through JMX/Jolokia of broker c01. This has the effect of disconnecting all consumers and producers from broker c01. It also disconnects all incoming network connectors.</li>
 	<li>The clients (producers &amp; consumers) will fail over to an active broker instance</li>
 	<li>Unconsumed messages in broker c01 will be forwarded to another broker instance since the network connect of broker c01 towards its neighbor is still active</li>
 	<li>Once all messages in broker c01 are consumed, we can shut down the entire instance</li>
</ul>

<a href="/assets/images/{{page.id}}/scaledown.png">
<img class="center-block img-responsive" src="/assets/images/{{page.id}}/scaledown.png" alt="scale down a network of brokers"/></a>
<p>
There might be situations where this procedure is not enough. Messages may remain when no active consumers for those exist anywhere in the network. In this case, I recommend you to look at Josh Reagan's blog post:

<a href="http://joshdreagan.github.io/2016/08/22/decommissioning_jboss_a-mq_brokers/">http://joshdreagan.github.io/2016/08/22/decommissioning_jboss_a-mq_brokers/</a>.
It describes how to read the message store to be decommissioned and forward all remaining messages.
</p>
<h2>How is the load distributed ?</h2>
<h3>Deactivate conduit subscriptions on queues for better load balancing</h3>
When messages are sent to brokers in layer 1, by default these are distributed in a round robin manner to brokers in layer 2.

For better load balancing on queues, conduit subscriptions can be deactivated on the brokers of layer 1. If consumers are not evenly distributed on layer 2, it allows brokers from layer 1 to be aware of that and apply the round robin algorithm on the different consumers rather than the brokers they are connected to.

To have a deeper understanding you can refer to the following documentation :

<a href="https://access.redhat.com/documentation/en/red-hat-jboss-a-mq/6.3/paged/using-networks-of-brokers/chapter-9-load-balancing">https://access.redhat.com/documentation/en/red-hat-jboss-a-mq/6.3/paged/using-networks-of-brokers/chapter-9-load-balancing</a>
<h3>Message hopping on layer 2 to avoid slow consumers</h3>

<a href="/assets/images/{{page.id}}/distributeload.png">
<img class="center-block img-responsive" src="/assets/images/{{page.id}}/distributeload.png" alt="distributed load in network of brokers"/></a>

If you run the tests that are provided in the sample code (see below). You might notice that sometimes a message that reaches a broker in layer 2 is forwarded to its neighbor on layer 2 instead of being consumed by the local client.

This is a very powerful feature of Active MQ that allows messages to be consumed as fast as possible within the network.

This usually happens when the local consumer is slowing down. A good messaging system is one that tends to contain 0 messages (all messages are consumed as soon as they are produced). So what we can observe here is that the network of brokers is doing it's best to move the messages around so that they are consumed as fast as possible.

On the other hand though, the consequences of this is that messages might get stuck at some point. There is a rule saying that a message cannot go back to a broker that has already been visited. So imagine if the fast consumer suddenly disconnects, our message here will get stuck in c01.
<h3>How to avoid stuck messages ?</h3>
To avoid messages getting stuck we need to add the replayWhenNoConsumers policy on the queues that are used within the network.
{% highlight xml %}
<policyEntry queue="sensor.events" queuePrefetch="1">
 <networkBridgeFilterFactory>
 <conditionalNetworkBridgeFilterFactory
 replayDelay="1000" replayWhenNoConsumers="true" />
 </networkBridgeFilterFactory>
</policyEntry>
{% endhighlight %}
This allows messages that are on a broker without any local consumer to revisit a previous broker.
<h3>Other important configurations</h3>
To ensure that the messages are prioritizing the shortest paths, these options need to be set on the network connectors :
<ul>
 	<li>decreaseNetworkConsumerPriority="true"</li>
 	<li>suppressDuplicateQueueSubscriptions="true"</li>
</ul>
&nbsp;
<h2>Sample code &amp; configurations</h2>
Nothing is better than a working example. A sample project can be found in the following GitHub repo : <a href="https://github.com/alainpham/amq-broker-network">https://github.com/alainpham/amq-broker-network</a>

This project populates 3 AMQ instances configured as a netwok of brokers similar to what is described in the sections above :


<a href="/assets/images/{{page.id}}/examplenetworkconfig.png">
<img class="center-block img-responsive" src="/assets/images/{{page.id}}/examplenetworkconfig.png" alt="example of amq network of brokers configuration"/></a>


<ul>
 	<li>s01 is the instance where the producers will connect to (layer 1). We only need on of those to understand the different concepts. This instance has 2 network connectors, one towards c01 and another one towards c02</li>
 	<li>c01 and c02 are the instances where the central consumers connect to in order to process messages (alyer 2). They each have a network connector towards each other</li>
</ul>
There are these test cases that you can run with the command
<pre>mvn test</pre>
<ul>
 	<li><strong>nominalSend1000Msg</strong>
<ul>
 	<li>create the network of 3 brokers with 1 producer and 2 consumers</li>
 	<li>send 1000 messages</li>
 	<li>each consumer receives roughly half of the messages</li>
 	<li>some messages hop between c01 and c02 when consumers are a bit slow</li>
</ul>
</li>
</ul>
<pre>[ main] TestAMQNetwork INFO Received on collector01 500
[ main] TestAMQNetwork INFO Received on collector02 500
[ main] TestAMQNetwork INFO Total received 1000
[ main] TestAMQNetwork INFO amqs01 enqueue 1000
[ main] TestAMQNetwork INFO amqs01 dequeue 1000
[ main] TestAMQNetwork INFO amqs01 dispatch 1000
[ main] TestAMQNetwork INFO amqc01master enqueue 501
[ main] TestAMQNetwork INFO amqc01master dequeue 501
[ main] TestAMQNetwork INFO amqc01master dispatch 501
[ main] TestAMQNetwork INFO amqc02master enqueue 501
[ main] TestAMQNetwork INFO amqc02master dequeue 501
[ main] TestAMQNetwork INFO amqc02master dispatch 501</pre>
<ul>
 	<li> <strong>scaleDown</strong>
<ul>
 	<li>create the network of 3 brokers with 1 producer and 2 consumers</li>
 	<li>send 500 messages</li>
 	<li>stop transport connector on c01</li>
 	<li>consumer on c01 reconnects to c02, remaining messages on c01 are drained</li>
 	<li>send another 500 messages</li>
 	<li>each consumer receives roughly half of the messages</li>
</ul>
</li>
</ul>
<pre>############### before scaleDown #########################
[ main] TestAMQNetwork INFO ###################################
[ main] TestAMQNetwork INFO ###################################
[ main] TestAMQNetwork INFO Received on collector01 250
[ main] TestAMQNetwork INFO Received on collector02 250
[ main] TestAMQNetwork INFO Total received 500
[ main] TestAMQNetwork INFO amqs01 enqueue 500
[ main] TestAMQNetwork INFO amqs01 dequeue 500
[ main] TestAMQNetwork INFO amqs01 dispatch 500
[ main] TestAMQNetwork INFO amqc01master enqueue 250
[ main] TestAMQNetwork INFO amqc01master dequeue 250
[ main] TestAMQNetwork INFO amqc01master dispatch 250
[ main] TestAMQNetwork INFO amqc02master enqueue 250
[ main] TestAMQNetwork INFO amqc02master dequeue 250
[ main] TestAMQNetwork INFO amqc02master dispatch 250</pre>
<pre> ############### scaleDown #########################
[ main] TestAMQNetwork INFO ##############################
[ main] TestAMQNetwork INFO ##############################
[ main] TestAMQNetwork INFO Received on collector01 501
[ main] TestAMQNetwork INFO Received on collector02 499
[ main] TestAMQNetwork INFO Total received 1000
[ main] TestAMQNetwork INFO amqs01 enqueue 1000
[ main] TestAMQNetwork INFO amqs01 dequeue 1000
[ main] TestAMQNetwork INFO amqs01 dispatch 1000
[ main] TestAMQNetwork INFO amqc01master enqueue 250
[ main] TestAMQNetwork INFO amqc01master dequeue 250
[ main] TestAMQNetwork INFO amqc01master dispatch 250
[ main] TestAMQNetwork INFO amqc02master enqueue 750
[ main] TestAMQNetwork INFO amqc02master dequeue 750
[ main] TestAMQNetwork INFO amqc02master dispatch 750

</pre>
<ul>
 	<li><strong>scaleUp</strong>
<ul>
 	<li>c01 is not started at the beginning, only s01 and c02 are up.</li>
 	<li>send 500 msgs</li>
 	<li>start c01</li>
 	<li>one of the consumer is forced to reconnected to c01</li>
 	<li>send another 500 msgs</li>
 	<li>each consumer receives roughly half of the messages</li>
 	<li>c01 starts to broke messages once it's up</li>
</ul>
</li>
</ul>
<pre>############### before scaleUp #########################
[ main] TestAMQNetwork INFO Received on collector01 250
[ main] TestAMQNetwork INFO Received on collector02 250
[ main] TestAMQNetwork INFO Total received 500
[ main] TestAMQNetwork INFO amqs01 enqueue 500
[ main] TestAMQNetwork INFO amqs01 dequeue 500
[ main] TestAMQNetwork INFO amqs01 dispatch 500
[ main] TestAMQNetwork INFO amqc01master enqueue 0
[ main] TestAMQNetwork INFO amqc01master dequeue 0
[ main] TestAMQNetwork INFO amqc01master dispatch 0
[ main] TestAMQNetwork INFO amqc02master enqueue 500
[ main] TestAMQNetwork INFO amqc02master dequeue 500
[ main] TestAMQNetwork INFO amqc02master dispatch 500

</pre>
<pre>############### scaleUp #########################
[ main] TestAMQNetwork INFO Received on collector01 500
[ main] TestAMQNetwork INFO Received on collector02 500
[ main] TestAMQNetwork INFO Total received 1000
[ main] TestAMQNetwork INFO amqs01 enqueue 1000
[ main] TestAMQNetwork INFO amqs01 dequeue 1000
[ main] TestAMQNetwork INFO amqs01 dispatch 1000
[ main] TestAMQNetwork INFO amqc01master enqueue 252
[ main] TestAMQNetwork INFO amqc01master dequeue 252
[ main] TestAMQNetwork INFO amqc01master dispatch 252
[ main] TestAMQNetwork INFO amqc02master enqueue 752
[ main] TestAMQNetwork INFO amqc02master dequeue 752
[ main] TestAMQNetwork INFO amqc02master dispatch 752</pre>

Thanks for reading !
