---
layout: default
title:  "컴퓨터 그래픽스 정리"
date:   2021-05-21 09:00:00 +0200
published: 2021-06-09 09:00:00 +0200
comments: true
categories: graphics
tags: [graphics, animation, opengl]
github: "https://github.com/OYSSanghyuk"
---



<p>
	Topic : 2차원, 3차원 그래픽스, 컴퓨터 그래픽스의 활용, 컴퓨터 그래픽스의 표준, opengl
</p>

<h2>2차원 그래픽스</h2>

<h4>벡터 그래픽스</h4>
<p>그래픽 객체들을 수학적함수로 표현하여 그래픽 명령어의 형태로 컴퓨터의 기억 공간에 저장하여
	기하학적 객체를 수식의 형태로 표현하므로 화면을 확대해도 화질의 변화가 없는 것이 특징인 방식
</p>

<h4>레스터 그래픽스</h4>
<p>그래픽 객체들을 구성하고 있는 픽셀들의 값들이 메모리에 그대로 저장되는 방식</p>

<h2>3차원 그래픽스</h2>

<h4>모델링</h4>
<p>3차원 좌표계에서 가상의 물체의 모양을 표현하는 과정
와이어프레임모델에서는 물체의 형태를 와이어프레임이라 불리는 선분을 이용하여 표현
다각형 표면모델은 삼각형이나 사각형같은 면을 기본단위로하여 물체의 외형을 표현</p>



<h4>투영</h4>
<p>모델링과정으로 형태가 구성이 되면 투영과정을 거친다. 투영과정이란 3차원 객체를 2차원화면에
	보여지게 처리하는 과정으로 이는 우리가 실제로 보여지는 디스플레이가 2차원 출력장치이기 때문에 필요한 과정이다.</p>


<h4>색상과 명암부여(랜더링)</h4>
<p>렌더링과정은 색상, 명암, 재질 및 그림자 같은 3차원적인 요소를 더하여 현실감을 추구하는 과정이다.
	렌더링 과정은 보는 사람이 객체를 볼 때 가려져서 안 보이는 은면을 제거하고
	, 색상과 명암을 나타내는 셰이딩과정, 그림이나 이미지로 기하모델의 표현을 덮어씌우는 텍스처매핑과정이 있다.</p>


<h4>이미지처리(Image Processing)</h4>
<p>이미지를 디지털화 한 후 입력된 그림을 이미지처리 소프트웨어로 편집한다.
	편집과정에서 사진의 품질을 향상시키거나 특별한 효과를 추가한다.</p>


<h4>애니메이션(Animation)</h4>
<p>애니메이션은 정지된 그림이나 이미지를 연속적으로 초당 15프레임이상 디스플레이하여 사람이 연속된 동작으로 느끼게 하는 기술이다.</p>


<h4>가상현실(VR : virtual reality)</h4>
<p>컴퓨터 그래픽스 기술을 이용하여 가상공간이나 가상의 물체를 구축하여 관찰자가 가상공간을 돌아다니며 체험하게 한다.
	- 3차원 공간, 물체를 초당 15프레임이상 디스플레이해야한다.
</p>


<h4>증강현실(AR : Augmented reality)</h4>
<p>컴퓨터 그래픽스 기술을 이요하여 실제현실에 가상의 사물이나 정보를 합성한다.</p>


<h2>컴퓨터 그래픽스의 활용</h2>

<h4>CAD(Computer Aided Design)</h4>
<p>CAD는 그래픽스 기술로 컴퓨터를 이용한 설계 분야이다. CAD 소프트웨어를 이용하여
	건축설계, 자동차, 비행기등 매우 광범위한 분야의 설계 및 도면작성을 할 수 있다,</p>

<h4>컴퓨터 애니메이션과 시뮬레이션(Simulation)</h4>
<p>애니메이션은 그래픽 프레임들을 연속적인 디스플레이를 통해 자연스럽게 보여주는 기법이다.
시뮬레이션은 교육, 훈련분야에서 많이 쓰고 모의실험으로 사용자의 입력 데이터에 따라 디스플레이 되는 결과가 변한다.</p>

<h4>컴퓨터 디자인 및 아트</h4>
<p>그래픽스 소프트웨어를 이용해 광고나 홍보물을 제작하여 활용하고 있고, 이처럼 상업디자인에 많이 활용되고 있지만 창작미술에도 활용되고 있다, </p>

<h4>게임 및 엔터테인먼트</h4>
<p>영화, 뮤직비디오, 게임등 엔터테인먼트를 제작할 때 자주 사용되고 있다. </p>

<h4>프리젠테이션 및 데이터 시각화(Data Visualization)</h4>
<p>컴퓨터가 생성한 각종 데이터를 그래픽을 통하여 제시해주는 분야를 프리젠테이션 그래픽스라고한다. 데이터를 차트나 그래프를 이용하여 표현한다.
	그리고 이를 바탕으로 컴퓨터 생성모델을 통하여 시각함으로써 자연형상이나 물리적 현상을 이해, 예측하는데 큰 도움을 줄 수 있다.</p>

<h4>멀티미디어</h4>
<p>이미지, 그래픽, 사운드, 애니메이션, 비디오 등과 같은 매체에서 그래픽스는 자주 이용된다. </p>

<h4>GUI(Graphical User Interface)</h4>
<p>GUI는 윈도우, 아이콘, 메뉴와 같은 그래픽 인터페이스를 통해 시각적으로 원하는 작업을 편리하게 용이하게 수행할 수 있게 해준다. </p>


<h4>전자출판</h4>
<p>잡지나 서적과 같은 출판물을 제작하는데도 이용되는데 이를 전자출판, 탁상출판(DTP : Desk-Top Publishing)이라고 한다.
	이를 이용하여 출판물의 레이아웃을 설계하고 그림이나 사진을 쉽게 편집하여 삽입하는 등의 일을 효과적으로 처리할 수 있다.</p>


<h4>공간정보의 표현</h4>
<p>교통, 환경, 지리, 토지 등의 공간정보를 2차원 또는 3차원 그래픽스로 표현함으로써 최적해를 찾아 합리적 의사결정을 내릴 수 있다.
	이러한 분야를 지리정보시스템(GIS: Geographic Information System)이라고 한다.</p>

<h4>이미지처리</h4>
<p>이미지처리는 외부에서 입력된 이미지의 질을 향상시키거나 입력된 이미지의 정보를 컴퓨터가 분석하고 이해하기 위해 사용한다. 예를 들면 MRI나 CT가 있다.</p>

<h2>그래픽스 시스템의 구성</h2>
<p>그래픽스 시스템의 구성

     그래픽스 프로그램(ex)포토샵), 그래픽 DB
	    ↓
입력장치 -> 프로세서 -> 프레임버퍼 -> 출력
	    ↓
            메모리
 </p>

<p>프레임버퍼 : 시스템 메모리와 그래픽 출력결과를 일시 저장해주는 메모리
그래픽스 프로그램 : 일반적으로 그래픽스 라이브러리가 제공하는 API(Application Program Interface)를 이용하여 개발한다. </P>

<h2>컴퓨터 그래픽스의 표준</h2>

<p>API - 고급 프로그래밍언어에서 그래픽스라이브러리를 호출</p>
<p>장치 인터페이스 – 입출력 장치와 표준적 방식으로 상호소통</p>
<p>그래픽 데이터 교환 – 그래픽스 응용프로그램간에 그래픽 데이터의 교환 및 저장</p>

<hr>


<h2>OpenGL</h2>

<h4>OpenGL의 특징</h4>
<p>1. opengl은 그래픽스 하드웨어에 대한 소프트웨어 인터페이스이다. 하드웨어에 독립적이고, 상위 수준의 그래픽스API다.
2. OpenGL은 플랫폼에 독립적이다. PC나 워크스테이션 모두에서 가능하고 다양한 운영체제 및 호스트 언어를 지원한다.
3. 다양한 그래픽스 기능의 지원으로 응용 소프트웨어 개발이 용이하다. 기본적인 2D 및 3D 그래픽스 함수에서부터 고급 기능까지 지원하고 그래픽스 가속기를 통해 많은 양의 데이터 처리가능</p>

<h4>OpenGL의 장점</h4>
<p>1. 안정성 – 다양한 플랫폼에서 지원되어 그 사양이 충분히 검증되면서 발전
2. 신뢰성 및 이식성 – OpenGL응용프로그램은 운영체제나 윈도우 시스템에 상관없이 동일한 출력결과를 생성
3. 확장성 – 다양한 종류의 시스템에서 동일하게 작동
4. 편리성 – 직관적인 인터페이스와 논리적인 명령어들로 구성
5. 문서화 – 문서화 작업이 잘 이루어져 있어 많은 책들이 출판</p>

<h4>OpenGL 라이브러리의 구성</h4>
<p>GL Library
OpenGL의 메인 라이브러리 기본적인 함수들이 모여있다.
GLU Library
OpenGL의 고급 기능의 유틸리티 함수들이 모여있다.
GLUT Library
인터페이스 툴킷 라이브러리, 현재 다양한 플랫폼 지원</p>

<h4>예시 코드 : OpenGL로 사각형 그리기</h4>
<pre><code>
#include <iostream>
#include <gl/glut.h>

void drawScene();
int main()
{
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGBA);
	glutInitWindowPostion(100, 100);
	glutInitWindowSize();
	glutCreateWindow(“Draw_Rect”);
	glutDisplayFunc(drawScene);

	glutMainLoop();
	return 0;
}

void drawScene()
{
	glClearColor()
	glClear(GL_COLOR_BUFFER_BIT);
	glColor4f()
	glBegin(GL_POLYGON);
		glVertex2i();
		glVertex2i();
		glVertex2i();	
		glVertex2i();
	glEnd();
	glFlush();
}
	</code></pre>




Thanks for reading !
